以下は、開発者がそのまま実装に着手できる粒度でまとめた要件定義書です。
（テーゼ／アンチテーゼ／アウフヘーベンは各所の「設計トレードオフ」に明示）

---

# 要件定義書：SNS投稿＋ブログ＋背景画像を自動生成するWebツール

## 0. スコープと非スコープ

* **対応環境**：PC／スマホ（モダンブラウザ最新2世代）
* **開発手段**：VSCode、（ローカル検証に）Gemini CLI
* **生成対象**

  * ステップ1：SNS短文案 80〜120文字×3
  * ステップ2：ユーザーが1案を選択
  * ステップ3（選択案を基に）

    * **SNS（Instagram）**：タイトル（20字以内）、本文（100〜150字）、ハッシュタグ5個
    * **ブログ**：見出し構造（H1〜H3）、本文（1,200〜2,000字）、中見出し適宜
  * **背景画像**（Gemini API）：SNS用 1080×1080、ブログ用 1200×630
  * **参考画像**（Gemini API）：文字入り／商品入りの叩き台（Canvaでの後加工前提）
* **出力**：テキストはコピー可能ボタン、画像はダウンロード可能ボタン
* **履歴**：ログインユーザー単位で**直近10件**保存・再利用
* **非スコープ（やらないこと）**：高度なデザインカスタマイズ、CMS自動投稿、利用データ集計分析、無制限履歴、30項目のブランド印象選択UI など

---

## 1. 技術スタック提案（理由付き）

### フロントエンド

* **Next.js 14（App Router） + React 18 + TypeScript**

  * **理由**：RSC/サーバーアクションで**APIキー秘匿**しつつ低レイテンシに寄与。型安全により生成結果の型定義・UI状態管理が堅牢。
* **UI**：Tailwind CSS + shadcn/ui

  * **理由**：短納期で**モバイル最適化**と一貫したデザインを確保。アクセシビリティ対応が容易。
* **状態管理**：RSC主体＋軽量なclient state（React Query）

  * **理由**：非同期生成の**進捗ポーリング**／SSE対応が簡潔。

### バックエンド

* **Next.js Route Handlers（/app/api/**）\*\*

  * **理由**：Vercelのサーバーレスに最適化。**APIキーはサーバーのみ**で扱う。
* **言語**：TypeScript（Zodで入出力バリデーション）
* **AI SDK**：Google AI（Gemini）Node SDK もしくは標準HTTP

  * **理由**：テキスト生成／画像生成双方の統一クライアント。CLIは**開発検証用**。
* **認証**：Auth.js（NextAuth）+ Google OAuth / Email Magic Link

  * **理由**：最短で安全なログイン導入。セッションCookieでフロントからのAPI呼出を保護。

### データストア & ストレージ

* **DB**：PostgreSQL（例：Vercel Postgres or Supabase Postgres）

  * **理由**：Prismaと相性が良く、JSON・配列など**柔軟**なスキーマが取れる。
* **オブジェクトストレージ**：Supabase Storage または Cloudflare R2（S3互換）

  * **理由**：画像の**原本保管**と**期限付き署名URL**配布が容易。
* **ORM**：Prisma

  * **理由**：スキーマ駆動で**型安全**、マイグレーション管理が容易。

### 運用

* **ホスティング**：Vercel（Preview/Prodブランチ）
* **監視**：Sentry（FE/BE）、Vercel Analytics
* **テスト**：Vitest（ユニット）、Playwright（E2E）
* **品質**：ESLint/Prettier、Husky + lint-staged

#### 設計トレードオフ（テーゼ／アンチテーゼ／アウフヘーベン）

* **T**：フルサーバーレスで運用コスト最小化
* **A**：バッチや長時間生成でスロットリングに弱い
* **S**：短時間APIはVercel、重い画像生成は**キューイング** + 冪等化で再試行（後述）

---

## 2. データベース設計（Prismaスキーマ）

> 方針：**GenerationSession**が1回の「生成」単位。3件の**Draft**、選択済み**Selection**、確定**SNSContent/BlogContent**、生成された**ImageAsset**をぶら下げる。履歴は**History**で最新10件に制御（古い非ピンを自動削除）。

```prisma
// schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
generator client {
  provider = "prisma-client-js"
}

enum ImageKind {
  SNS_BACKGROUND
  BLOG_BACKGROUND
  REFERENCE
}

enum SessionStatus {
  CREATED
  DRAFTS_READY
  CONTENT_READY
  IMAGES_READY
  COMPLETED
  ERROR
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  image     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions  GenerationSession[]
  histories History[]
}

model GenerationSession {
  id          String        @id @default(cuid())
  user        User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String

  // 入力（システムプロンプトはサーバ固定・バージョン管理）
  productName       String
  productImageUrl   String? // httpsのみ許可・サーバ側でフェッチ検証
  priceJpy          Int?    // 金額は任意
  buyUrl            String? // httpsのみ許可
  systemPromptVer   String  // 例: "v1.0.0"

  // 状態管理
  status       SessionStatus @default(CREATED)
  errorMessage String?

  drafts     Draft[]
  selection  Selection?
  sns        SNSContent?
  blog       BlogContent?
  images     ImageAsset[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId, createdAt])
}

model Draft {
  id        String             @id @default(cuid())
  session   GenerationSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String
  idx       Int                // 0..2
  text      String             // 80〜120文字
  createdAt DateTime           @default(now())

  @@unique([sessionId, idx])
}

model Selection {
  id           String            @id @default(cuid())
  session      GenerationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId    String
  selectedIdx  Int               // 選択したDraftのidx
  draftId      String            // 冪等性確保用（選択元）
  createdAt    DateTime          @default(now())

  @@unique([sessionId])
}

model SNSContent {
  id        String            @id @default(cuid())
  session   GenerationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String

  title     String            // 20字以内（サーバ側で検証）
  body      String            // 100〜150字
  hashtags  String[]          // 5〜10個（#はクライアントレンダリング時付与可）

  bgImage   ImageAsset?       @relation("SnsBg", fields: [bgImageId], references: [id])
  bgImageId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model BlogContent {
  id        String            @id @default(cuid())
  session   GenerationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String

  h1        String
  outline   Json              // H2/H3構造（[{h2, h3:[...]}, ...]）
  bodyMd    String            // Markdown本文（1200〜2000字）

  bgImage   ImageAsset?       @relation("BlogBg", fields: [bgImageId], references: [id])
  bgImageId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ImageAsset {
  id        String            @id @default(cuid())
  session   GenerationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String

  kind      ImageKind
  objectKey String            // ストレージのキー
  mimeType  String            // image/png, image/jpeg, image/webp
  width     Int
  height    Int
  prompt    String            // 生成に用いたプロンプト（PII/APIキー含まない）
  createdAt DateTime          @default(now())

  // 逆参照（任意）
  snsBg  SNSContent[] @relation("SnsBg")
  blogBg BlogContent[] @relation("BlogBg")
}

model History {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  session   GenerationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String

  title     String?  // 一覧用サマリ（例：SNSタイトル）
  pinned    Boolean  @default(false) // ピン留めで10件制限から除外可（任意）
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}
```

**10件制限ロジック**（アプリ側）：`History`新規追加後に `pinned = false` の古いものを削除して件数を10以下に保つ。

---

## 3. API設計（REST）

> 認証はセッションクッキー（Auth.js）。すべてのAPIは**サーバー側**でGemini APIを呼び出し、フロントには**結果のみ**返す。

| #  | Method | Path                                | 役割 / 概要                   | Auth | 主なRequest                                               | 主なResponse（200）                                                                     |
| -- | ------ | ----------------------------------- | ------------------------- | ---- | ------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| 1  | POST   | `/api/sessions`                     | 生成セッション開始＋短文案3件生成（Step1）  | 必須   | `{ productName, productImageUrl?, priceJpy?, buyUrl? }` | `{ sessionId, drafts: [{idx,text}×3], status: "DRAFTS_READY" }`                     |
| 2  | POST   | `/api/sessions/:id/selection`       | 案の確定（Step2）               | 必須   | `{ selectedIdx }`                                       | `{ sessionId, selection: {selectedIdx}, status: "DRAFTS_READY" }`                   |
| 3  | POST   | `/api/sessions/:id/content`         | SNS/ブログ本文生成（Step3-テキスト）   | 必須   | （空、または再生成フラグ）                                           | `{ sns:{title,body,hashtags[]}, blog:{h1,outline,bodyMd}, status:"CONTENT_READY" }` |
| 4  | POST   | `/api/sessions/:id/images`          | 背景画像＆参考画像生成（Step3-画像）     | 必須   | `{ regenerate?: boolean }`                              | `{ images:[{id,kind,width,height,objectKey,mimeType}], status:"IMAGES_READY" }`     |
| 5  | GET    | `/api/sessions/:id`                 | セッション詳細取得（合算結果）           | 必須   | -                                                       | `{ session, drafts, selection, sns, blog, images }`                                 |
| 6  | GET    | `/api/history?limit=10`             | 履歴一覧（最新10）                | 必須   | -                                                       | `{ items:[{historyId, sessionId, title, createdAt}] }`                              |
| 7  | POST   | `/api/history/:historyId/duplicate` | 履歴から再利用（新規セッション作成）        | 必須   | -                                                       | `{ newSessionId }`                                                                  |
| 8  | DELETE | `/api/history/:historyId`           | 履歴削除                      | 必須   | -                                                       | `{ ok:true }`                                                                       |
| 9  | GET    | `/api/images/:imageId/download`     | 期限付き署名URLを発行（実ファイルはストレージ） | 必須   | -                                                       | `{ url, expiresAt }`                                                                |
| 10 | GET    | `/api/sessions/:id/events`          | SSEで進捗通知（任意）              | 必須   | -                                                       | `event:progress` などのSSEストリーム                                                        |

**バリデーション（例：Zod）**

* `productImageUrl/buyUrl` は `https` のみ、最大長 2048、拡張子/Content-Type検証。
* SNSタイトル ≤20字、本文 100–150字、ハッシュタグ 5–10個。
* ブログ本文 1200–2000字、H構造は outline JSON の整合チェック。

**エラーレスポンス**

* `400`：検証失敗（詳細コードとフィールド配列）
* `401`：未認証
* `429`：レート制限（後述）
* `502/504`：下流AI失敗・タイムアウト（再試行トークン返却）

#### 設計トレードオフ

* **T**：Step3を1エンドポイントで**同期一括生成**してUX簡素化
* **A**：画像生成が重く**タイムアウト**し得る
* **S**：テキストと画像を**分離**（上表3/4）。必要ならSSE（#10）で進捗通知

---

## 4. 画面仕様案（URL & 要素）

1. **ランディング** `/`

   * CTA：ログイン／「今すぐ作る」
   * 価値提案／生成例サンプル／利用規約・プライポリ

2. **ログイン** `/login`

   * Googleでログイン／メールリンク

3. **ダッシュボード** `/dashboard`

   * フォーム：

     * 商品名（必須）
     * 商品画像URL（任意）
     * 価格（任意・半角数値）
     * 買える場所URL（任意）
   * 「短文案を生成」→ POST `/api/sessions`

4. **短文案選択（Step1/2）** `/sessions/[id]/drafts`

   * 3案カード表示（80〜120字）
   * 「コピー」／「この案で進む」→ POST selection
   * 再生成（任意）ボタン

5. **結果（Step3）** `/sessions/[id]/result`

   * **SNS**：タイトル（20字以内）・本文（100〜150字）・ハッシュタグ5

     * 「コピー」ボタン（各要素）
   * **ブログ**：H1〜H3構造＋本文（Markdownビュー）

     * 「本文をコピー」
   * **画像**：SNS背景（1080×1080）、ブログ背景（1200×630）、参考画像

     * 「ダウンロード」ボタン（GET download）
   * 「履歴に保存」（自動）、再生成（テキスト／画像別）

6. **履歴** `/history`

   * 最新10件タイル（タイトル、生成日、プレビュー）
   * 「再利用」「削除」

7. **設定** `/settings`（任意）

   * アカウント削除、利用制限の表示

**レスポンシブ**：モバイルはカード縦積み、コピー／DLボタンは**親指到達**位置優先で固定バーも可。

---

## 5. アーキテクチャ & セキュリティ

### コンポーネント図（ASCII）

```
[Browser SPA/SSR]
     | HTTPS (Cookie Session)
     v
[Next.js API (Route Handlers)]
  |-- Validate (Zod)
  |-- Rate Limit (per user)
  |-- Call Gemini (server-only, ENV KEY)
  |-- Persist (Prisma -> Postgres)
  |-- Store Images (Signed PUT to Storage)
     |
     +-> [Gemini API]  (text/image)
     +-> [Postgres]
     +-> [Object Storage]  <--(signed GET)-- Browser Download
```

### APIキーの安全な取り扱い

* **原則**：**フロントにGemini APIキーを一切渡さない**。Next.jsサーバーのみが `process.env.GEMINI_API_KEY` を使用。
* **環境変数**：VercelのEncrypted Env。Preview/Prodで分離。Rotate手順をRunbook化。
* **通信**：サーバー→GeminiはHTTPS/TLS1.2+。タイムアウトと指数バックオフ、冪等キー（`Idempotency-Key`）を実装。
* **画像ダウンロード**：クライアントは\*\*署名付きURL（短期期限）\*\*を受け取り直接ストレージへ。APIキーに触れない。

### 認可・データ境界

* セッション／履歴は**userIdスコープ**で強制フィルタ。Row-Level Authorizationをアプリ層で実装（クエリにuserId必須）。
* CSRF：Auth.jsの**SameSite=Lax**＋APIは\*\*`POST/DELETE`のみstateful\*\*。GETは副作用なし。
* CORS：自ドメインのみ許可。
* 入力検証：Zodスキーマで**長さ／形式／https限定**。画像URLはサーバーからフェッチし**MIME検証**・サイズ上限（例：5MB）。
* 出力整形：XSS対策（ブログ本文はMarkdown→サニタイズHTMLにレンダリング）。

### レート制限 & コスト防衛

* **ユーザー単位**：例）テキスト生成 30回/日、画像生成 20回/日
* 実装：Upstash Redis等の**トークンバケット**。`429`で明示メッセージ。
* 失敗時再試行：画像のみ**ジョブID**で冪等化。フロントは進捗ポーリング or SSE。

### ログ & 個人情報

* 生成プロンプトは**最小限**記録（商品名等の入力のみ）。本文は保存が要件のためDBに保持。
* 監査ログ：`userId`, `sessionId`, 操作種別, IPハッシュ, UA。

#### 設計トレードオフ

* **T**：クライアントから直接ストレージへPUT（署名URL）で**帯域節約**
* **A**：署名漏えい時の不正PUTリスク
* **S**：署名は**短寿命＋1回限り**、Content-MD5検証・`Content-Type`固定

---

## 6. 生成プロンプト（サーバ固定・バージョン管理）

* **systemPrompt（v1.0.0）**：ご提示の文面を**サーバー内の定数**として埋め込み。将来の変更に備え`systemPromptVer`をセッションに保存。
* **ユーザー入力**：`productName, productImageUrl, priceJpy, buyUrl`
* **Step1**：短文案3件（80–120字、感情喚起）
* **Step3**：選択案をコンテキストにSNS/ブログ本文＋背景画像プロンプトを生成
* **画像生成**：

  * SNS背景：1080×1080、商品テーマに合致、テキスト載せない（Canva想定）
  * ブログ背景：1200×630、OGP向き
  * 参考画像：**文字入り／商品入り**の粗素材（注意文言をUIに表示）

---

## 7. 主要ユースケースとシーケンス

**短文案→確定→結果生成（テキスト・画像）**

1. `/api/sessions` → Geminiで短文案3
2. ユーザー選択 → `/api/sessions/:id/selection`
3. テキスト生成 → `/api/sessions/:id/content`
4. 画像生成 → `/api/sessions/:id/images`
5. `History`へ追加（>10なら古い非ピン削除）

（任意）SSE `/api/sessions/:id/events` で `drafts_ready → content_ready → images_ready → completed` を通知。

---

## 8. コピー／ダウンロード仕様

* **コピー**：クリップボードAPI（非同期）＋トースト通知。
* **画像DL**：`/api/images/:id/download` が**期限付きURL**を返却 → `<a download>` クリックで保存。
* **ファイル名規約**：`{date}_{sessionId}_{kind}.png` など。

---

## 9. 非機能要件

* **性能**：Step1（短文案）はp95 < 3s、Step3テキスト p95 < 5s、画像は<= 20s（非同期許容）
* **可用性**：Vercel SLA準拠、障害時は「後で画像のみ再生成」導線
* **セキュリティ**：OWASP ASVS L1相当、依存パッケージの自動脆弱性スキャン

---

## 10. マイルストーン（実装順）

1. スキャフォールド（Next.js/TS/Tailwind/Auth.js/Prisma/DB接続）
2. `/api/sessions`（Step1）＋ `/sessions/[id]/drafts` UI
3. `/selection` → `/content`（テキスト完結、履歴10件）
4. 画像生成とストレージ・DL
5. 履歴一覧／再利用
6. レート制限／監視／E2Eテスト
7. SSE（任意）、微調整

---

## 11. 簡易テスト観点

* 文字数・件数制約（境界値：20/100/150/1200/2000）
* URL検証（http拒否・長大URL・Content-Type偽装）
* 10件超過時の履歴削除順（ピン留めの保持）
* 画像生成失敗時の**部分成功**（テキストは残す）
* 再生成の冪等性（同一ジョブIDで二重反映防止）

---

## 12. 追加の実装メモ（開発者向け）

* **型**：`Hashtag`は`string`配列。`#`はUIで付与する運用が堅牢（重複/全角ハッシュ防止）。
* **Markdown**：ブログ本文はMarkdown保存→表示時に`rehype-sanitize`。
* **i18n**：ラベルは`next-intl`、文言キー化。
* **コスト**：画像は**WebP**優先で保存（サイズ削減）。
* **アクセシビリティ**：生成画像の代替テキストもモデルからサジェスト。

---

### 補足：代表的なコードスケッチ（型の雰囲気）

```ts
// POST /api/sessions
const BodySchema = z.object({
  productName: z.string().min(1).max(100),
  productImageUrl: z.string().url().startsWith("https").optional(),
  priceJpy: z.number().int().positive().max(10_000_000).optional(),
  buyUrl: z.string().url().startsWith("https").optional(),
});

type Draft = { idx: number; text: string };

type SnsContent = { title: string; body: string; hashtags: string[] };
type BlogContent = { h1: string; outline: any; bodyMd: string };
```

---

## 13. まとめ（アウフヘーベン）

* **安全性**：APIキーは**完全サーバー完結**、署名URLで画像配布、入力はZod検証。
* **使いやすさ**：生成を**テキストと画像に分離**、部分成功と再生成を前提に**失敗に強い**。
* **拡張性**：`GenerationSession`中心のスキーマで将来の多モデル・マルチ出力も吸収。
* **運用**：履歴10件制限・レート制限で**コスト暴発**を回避。

---
